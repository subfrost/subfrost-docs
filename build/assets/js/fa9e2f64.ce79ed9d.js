"use strict";(self.webpackChunksubfrost_docs=self.webpackChunksubfrost_docs||[]).push([[328],{7692:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"developer-guide/subrail","title":"Subrail Runtime","description":"Subrail is the high-performance WebAssembly (WASM) runtime at the heart of the SUBFROST node. It is specifically designed to execute the consensus-critical logic of Alkanes and other state transition functions within the SUBFROST ecosystem.","source":"@site/docs/developer-guide/subrail.mdx","sourceDirName":"developer-guide","slug":"/developer-guide/subrail","permalink":"/developer-guide/subrail","draft":false,"unlisted":false,"editUrl":"https://github.com/subfrost/subfrost/tree/main/docs/developer-guide/subrail.mdx","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Subrail Runtime","sidebar_position":5},"sidebar":"docs","previous":{"title":"Alkanes Metaprotocol","permalink":"/developer-guide/alkanes"},"next":{"title":"subfrost-node CLI","permalink":"/references/subfrost-node-cli"}}');var i=n(4848),o=n(8453);const r={title:"Subrail Runtime",sidebar_position:5},c="Subrail Runtime",a={},l=[{value:"Purpose and Design",id:"purpose-and-design",level:2},{value:"Execution Lifecycle",id:"execution-lifecycle",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"subrail-runtime",children:"Subrail Runtime"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"Subrail"})," is the high-performance WebAssembly (WASM) runtime at the heart of the SUBFROST node. It is specifically designed to execute the consensus-critical logic of Alkanes and other state transition functions within the SUBFROST ecosystem."]}),"\n",(0,i.jsx)(t.h2,{id:"purpose-and-design",children:"Purpose and Design"}),"\n",(0,i.jsxs)(t.p,{children:["The primary purpose of ",(0,i.jsx)(t.code,{children:"Subrail"})," is to provide a secure, deterministic, and fast execution environment for the programs that define the SUBFROST protocol. By using WASM, ",(0,i.jsx)(t.code,{children:"Subrail"})," allows for protocol logic to be developed in any language that can compile to a WASM target (such as Rust, C++, or Go), offering developers flexibility without sacrificing performance."]}),"\n",(0,i.jsx)(t.p,{children:"Key design features include:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Sandboxed Execution:"})," All WASM modules are executed in a sandboxed environment, preventing them from accessing the host system's resources and ensuring the determinism required for consensus."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"State Management:"})," ",(0,i.jsx)(t.code,{children:"Subrail"})," integrates directly with the node's state database. It provides the WASM guest with an API to read from and write to the world state, but only in a controlled, transactional manner."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsxs)(t.strong,{children:["Integration with ",(0,i.jsx)(t.code,{children:"metashrew"}),":"]})," ",(0,i.jsx)(t.code,{children:"Subrail"})," is powered by ",(0,i.jsx)(t.code,{children:"metashrew"}),", a specialized Bitcoin blockchain indexer. ",(0,i.jsx)(t.code,{children:"metashrew"})," processes Bitcoin blocks, extracts relevant data (like ",(0,i.jsx)(t.code,{children:"OP_RETURN"})," outputs containing Runestones), and provides this data to the ",(0,i.jsx)(t.code,{children:"Subrail"})," runtime. This allows Alkane contracts to be aware of and react to events on the Bitcoin L1."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"execution-lifecycle",children:"Execution Lifecycle"}),"\n",(0,i.jsxs)(t.p,{children:["When a ",(0,i.jsx)(t.code,{children:"subfrost-node"})," processes a new block, the following occurs:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Data Ingestion:"})," The ",(0,i.jsx)(t.code,{children:"metashrew"})," component of the node parses the block and identifies any transactions containing Runestones."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Runtime Invocation:"})," The data from the Runestone (edicts, calldata, etc.) is passed to the ",(0,i.jsx)(t.code,{children:"Subrail"})," runtime."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"WASM Execution:"})," ",(0,i.jsx)(t.code,{children:"Subrail"})," loads the appropriate Alkane WASM module (e.g., the ",(0,i.jsx)(t.code,{children:"frBTC"})," contract) and executes it, passing the Runestone data as input."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"State Transition:"})," The WASM module executes its logic. If it's a ",(0,i.jsx)(t.code,{children:"mint"})," operation, it will calculate the new ",(0,i.jsx)(t.code,{children:"frBTC"})," balance and use the ",(0,i.jsx)(t.code,{children:"Subrail"})," API to write this new state to a pending state transition."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"State Commit:"})," Once the block is fully processed and consensus is reached, the pending state transitions are committed to the node's database, finalizing the changes."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"This architecture separates the core node logic from the application-specific logic of the Alkanes, making the entire system more modular, secure, and upgradeable."})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>c});var s=n(6540);const i={},o=s.createContext(i);function r(e){const t=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);